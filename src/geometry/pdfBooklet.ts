import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import type { Part, DesignParams, Material } from './types';
import { getThicknessInInches, isImperialMaterial, isMetricMaterial } from './types';
import { toFraction32, formatDimensionsWithUnit } from './format';
import { svgToPng } from '../lib/svgToImage';
import { generateSheetLayouts } from './ripGenerator';
import { generateAllSheetSvgs, generateOversizedPartSvgs } from './cutListSvg';
import { generateAllAssemblyGuideSvgs } from './assemblyGuideSvg';
import { captureAxonometricView } from './sceneCapture';
import instructionGuysUrl from '../assets/InstructionGuys.png';

/**
 * Helper to format material thickness for display
 */
function formatMaterialThickness(material: Material, unitSystem: 'imperial' | 'metric'): string {
  if (isImperialMaterial(material)) {
    return material.nominal;
  } else {
    return `${material.thicknessMm}mm`;
  }
}

export async function generatePDFBooklet(
  parts: Part[], 
  params: DesignParams,
  title: string = 'Custom Modular Shelving'
): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  
  // Page dimensions (Landscape Letter: 11" x 8.5")
  const pageWidth = 792;
  const pageHeight = 612;
  const margin = 40;
  const contentWidth = pageWidth - 2 * margin;
  
  // Helper function to add a page
  const addPage = () => pdfDoc.addPage([pageWidth, pageHeight]);
  
  // Site URL for instructions
  const siteUrl = 'kallax-configurator.app';
  
  // Helper function to get door configuration description
  const getDoorDescription = () => {
    if (!params.hasDoors) return 'no doors';
    if (params.doorMode.type === 'inset') return 'inset doors';
    return 'overlay doors';
  };
  
  // Helper function to get back description
  const getBackDescription = () => params.hasBack ? 'back' : 'no back';
  
  // ===== PAGE 1: Title Page =====
  const page1 = addPage();
  let yPos = pageHeight - margin;
  
  // Header
  page1.drawText(title, {
    x: margin,
    y: yPos,
    size: 24,
    font: helveticaBoldFont,
    color: rgb(0, 0, 0),
  });
  yPos -= 30;
  
  page1.drawText(`${params.cols} x ${params.rows} with ${getBackDescription()} and ${getDoorDescription()}`, {
    x: margin,
    y: yPos,
    size: 16,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  
  
  yPos = pageHeight - margin - 80;
  const bodyText = `Overview for assembling a plywood modular shelving unit generated by ${siteUrl}. Note that this app does not generate detailed assembly instructions, but will give you an overview of your options.`;
  
  const leftColumnWidth = 600;
  const words = bodyText.split(' ');
  let currentLine = '';
  const lines: string[] = [];
  
  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const textWidth = helveticaFont.widthOfTextAtSize(testLine, 12);
    
    if (textWidth > leftColumnWidth && currentLine) {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) lines.push(currentLine);
  
  for (const line of lines) {
    page1.drawText(line, {
      x: margin,
      y: yPos,
      size: 12,
      font: helveticaFont,
    });
    yPos -= 16;
  }
  
  // Axonometric view (centered, wider)
  const imageWidth = 450; // Wider
  const imageHeight = 350; // Keep same height
  const imageX = (pageWidth - imageWidth) / 2; // Centered
  const imageY = yPos - imageHeight;
  
  // Generate and embed axonometric view from 3D scene capture
  try {
    const axonometricBlob = await captureAxonometricView(
      params,
      Math.round(imageWidth * 2), // Higher resolution for better quality
      Math.round(imageHeight * 2)
    );
    
    const axonometricPngBytes = new Uint8Array(await axonometricBlob.arrayBuffer());
    const axonometricImage = await pdfDoc.embedPng(axonometricPngBytes);
    const scaledDims = axonometricImage.scale(Math.min(imageWidth / axonometricImage.width, imageHeight / axonometricImage.height));
    
    // Center the axonometric view
    const centeredX = imageX + (imageWidth - scaledDims.width) / 2;
    const centeredY = imageY + (imageHeight - scaledDims.height) / 2;
    
    page1.drawImage(axonometricImage, {
      x: centeredX,
      y: centeredY - 50,
      width: scaledDims.width,
      height: scaledDims.height,
    });
  } catch (error) {
    console.warn('Failed to generate axonometric view:', error);
    
    // Fallback placeholder
    page1.drawRectangle({
      x: imageX,
      y: imageY,
      width: imageWidth,
      height: imageHeight,
      borderColor: rgb(0.8, 0.8, 0.8),
      borderWidth: 1,
    });
    page1.drawText('Axonometric View\n(Generation failed)', {
      x: imageX + imageWidth/2 - 70,
      y: imageY + imageHeight/2,
      size: 12,
      font: helveticaFont,
      color: rgb(0.6, 0.6, 0.6),
    });
  }
  
  
  // ===== PAGE 2: Instruction Guys =====
  const page2 = addPage();
  
  try {
    // Load and embed instruction guys image scaled to 80% of page width, centered
    const instructionGuysBytes = await fetch(instructionGuysUrl).then(res => res.arrayBuffer());
    const instructionGuysImage = await pdfDoc.embedPng(instructionGuysBytes);
    
    // Scale to 80% of page width while maintaining aspect ratio
    const targetWidth = pageWidth * 0.8;
    const scale = targetWidth / instructionGuysImage.width;
    const scaledWidth = instructionGuysImage.width * scale;
    const scaledHeight = instructionGuysImage.height * scale;
    
    // Center the scaled image on the page
    const imageX = (pageWidth - scaledWidth) / 2;
    const imageY = (pageHeight - scaledHeight) / 2;
    
    page2.drawImage(instructionGuysImage, {
      x: imageX,
      y: imageY,
      width: scaledWidth,
      height: scaledHeight,
    });
  } catch (error) {
    console.warn('Failed to load instruction guys image:', error);
    // Fallback placeholder
    page2.drawText('Instruction Guys Image\n(Failed to load)', {
      x: pageWidth / 2 - 100,
      y: pageHeight / 2,
      size: 16,
      font: helveticaFont,
      color: rgb(0.6, 0.6, 0.6),
    });
  }
  
  // ===== PAGE 3: Configurations + Pieces =====
  const page3 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page3.drawText('Configurations + Pieces', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 25;
  
  page3.drawText('Configurations set by user, and tabulated cut list', {
    x: margin,
    y: yPos,
    size: 14,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  yPos -= 40;
  
  // Grid Configuration and Layout (drawn with native PDF vectors)
  const { rows, cols, merges } = params;
  const baseCellSize = 30; // Base cell size
  const strokeWidth = 1;
  const borderWidth = 2;
  
  // Calculate max dimensions based on 6x6 grid
  const maxGridHeight = 6 * baseCellSize + borderWidth * 2 - 20; // 164px
  const maxGridWidth = maxGridHeight + 100; // 264px
  
  // Calculate actual grid dimensions
  const naturalWidth = cols * baseCellSize + borderWidth * 2;
  const naturalHeight = rows * baseCellSize + borderWidth * 2;
  
  // Scale proportionally if needed
  const scaleX = naturalWidth > maxGridWidth ? maxGridWidth / naturalWidth : 1;
  const scaleY = naturalHeight > maxGridHeight ? maxGridHeight / naturalHeight : 1;
  const scale = Math.min(scaleX, scaleY);
  
  const cellSize = baseCellSize * scale;
  const gridWidth = naturalWidth * scale;
  const gridHeight = naturalHeight * scale;
  
  const gridX = margin;
  const gridY = yPos - gridHeight;
  
  // Helper function to check if a cell is part of a merge
  const getCellMerge = (row: number, col: number) => {
    return merges.find(merge =>
      row >= merge.r0 && row <= merge.r1 && col >= merge.c0 && col <= merge.c1
    ) || null;
  };
  
  // Helper function to check if a cell is the top-left origin of a merge
  const isMergeOrigin = (row: number, col: number, merge: any) => {
    return row === merge.r0 && col === merge.c0;
  };
  
  // Outer border (no fill, black stroke)
  page3.drawRectangle({
    x: gridX,
    y: gridY,
    width: gridWidth,
    height: gridHeight,
    borderColor: rgb(0, 0, 0),
    borderWidth: borderWidth,
  });
  
  // Generate cells
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const merge = getCellMerge(row, col);
      const isOrigin = merge && isMergeOrigin(row, col, merge);
      const isInMerge = merge && !isOrigin;
      
      // Don't render cells that are covered by a merge (except origin)
      if (isInMerge) continue;
      
      const cellX = gridX + borderWidth + col * cellSize;
      const cellY = gridY + borderWidth + row * cellSize;
      
      let cellWidth = cellSize;
      let cellHeight = cellSize;
      
      // Handle merged cells
      if (merge) {
        cellWidth = (merge.c1 - merge.c0 + 1) * cellSize;
        cellHeight = (merge.r1 - merge.r0 + 1) * cellSize;
      }
      
      // Cell rectangle (no fill, black stroke)
      page3.drawRectangle({
        x: cellX,
        y: cellY,
        width: cellWidth,
        height: cellHeight,
        borderColor: rgb(0, 0, 0),
        borderWidth: strokeWidth,
      });
      
      // Cell text
      const textX = cellX + cellWidth / 2;
      const textY = cellY + cellHeight / 2;
      
      if (merge) {
        page3.drawText(`${merge.c1 - merge.c0 + 1}×${merge.r1 - merge.r0 + 1}`, {
          x: textX - 10,
          y: textY - 5,
          size: 8,
          font: helveticaBoldFont,
          color: rgb(0, 0, 0),
        });
      } else {
        page3.drawText(`${row},${col}`, {
          x: textX - 8,
          y: textY - 3,
          size: 7,
          font: helveticaFont,
          color: rgb(0.4, 0.4, 0.4),
        });
      }
    }
  }
  
  // Chart 1: All Configurations (right side)
  const configX = margin + 250;
  let configY = yPos;
  
  page3.drawText('Configuration:', {
    x: configX,
    y: configY,
    size: 12,
    font: helveticaBoldFont,
  });
  configY -= 20;
  
  const unitLabel = params.unitSystem === 'metric' ? 'mm' : '"';
  const configs = [
    `Grid Layout: ${params.rows} rows × ${params.cols} columns`,
    `Module Size: ${params.unitSystem === 'metric' ? Math.round(params.interiorClearance) : toFraction32(params.interiorClearance)}${unitLabel}`,
    `Depth: ${params.unitSystem === 'metric' ? Math.round(params.depth) : toFraction32(params.depth)}${unitLabel}`,
    `Back Panel: ${params.hasBack ? 'Yes' : 'No'}`,
    `Doors: ${params.hasDoors ? 'Yes' : 'No'}`,
    `Frame Thickness: ${formatMaterialThickness(params.materials.frame, params.unitSystem)}`,
  ];

  if (params.hasBack && params.materials.back) {
    configs.push(`Back Thickness: ${formatMaterialThickness(params.materials.back, params.unitSystem)}`);
  }

  if (params.hasDoors && params.materials.door) {
    configs.push(`Door Thickness: ${formatMaterialThickness(params.materials.door, params.unitSystem)}`);
    configs.push(`Door Style: ${params.doorMode.type}`);
    if (params.doorMode.type === 'inset') {
      const revealDisplay = params.unitSystem === 'metric' ? `${Math.round(params.doorMode.reveal)}mm` : `${toFraction32(params.doorMode.reveal)}"`;
      configs.push(`Door Reveal: ${revealDisplay}`);
    } else {
      const overlayDisplay = params.unitSystem === 'metric' ? `${Math.round(params.doorMode.overlay)}mm` : `${toFraction32(params.doorMode.overlay)}"`;
      configs.push(`Door Overlay: ${overlayDisplay}`);
    }
  }
  
  for (const config of configs) {
    page3.drawText(`• ${config}`, {
      x: configX,
      y: configY,
      size: 10,
      font: helveticaFont,
    });
    configY -= 15;
  }
  
  // Chart 2: Parts List (bottom half)
  configY = yPos - 200;
  page3.drawText('Parts List:', {
    x: margin,
    y: configY,
    size: 12,
    font: helveticaBoldFont,
  });
  configY -= 20;
  
  // Parts table header
  page3.drawText('Part ID', { x: margin, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Role', { x: margin + 100, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Qty', { x: margin + 180, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Dimensions', { x: margin + 210, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Notes', { x: margin + 350, y: configY, size: 9, font: helveticaBoldFont });
  
  configY -= 15;
  page3.drawLine({
    start: { x: margin, y: configY },
    end: { x: pageWidth - margin, y: configY },
    thickness: 1,
    color: rgb(0, 0, 0),
  });
  configY -= 10;
  
  // List parts (limited to available space)
  for (let i = 0; i < parts.length && configY > margin + 30; i++) {
    const part = parts[i];
    page3.drawText(part.id, { x: margin, y: configY, size: 8, font: helveticaFont });
    page3.drawText(part.role, { x: margin + 100, y: configY, size: 8, font: helveticaFont });
    page3.drawText(part.qty.toString(), { x: margin + 180, y: configY, size: 8, font: helveticaFont });
    page3.drawText(formatDimensionsWithUnit(part.lengthIn, part.widthIn, part.thicknessIn, params.unitSystem), {
      x: margin + 210, y: configY, size: 8, font: helveticaFont
    });
    
    if (part.notes) {
      const notes = part.notes.length > 100 ? part.notes.substring(0, 27) + '...' : part.notes;
      page3.drawText(notes, { 
        x: margin + 350, y: configY, size: 7, font: helveticaFont, color: rgb(0.4, 0.4, 0.4)
      });
    }
    
    configY -= 12;
  }
  
  // ===== PAGE 4: Connections and Assembly Methods =====
  const page4 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page4.drawText('Connections and Assembly Methods', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 25;
  
  page4.drawText('Suggestions for how to assemble', {
    x: margin,
    y: yPos,
    size: 14,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  yPos -= 40;

  // Add metric note if in metric mode
  if (params.unitSystem === 'metric') {
    page4.drawText('**Note: I have only assembled this using imperial sheet goods, look for best practices with metric.**', {
      x: margin,
      y: yPos,
      size: 10,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
    yPos -= 15;
  }

  // Assembly methods content
  const assemblyText = `For 3/4" plywood modular shelving, consider these assembly methods:

\n\n
BUTT JOINTS:
\n
• Hidden screws: Pre-drill and countersink, use wood plugs to hide screw heads
• Pocket screws: Use pocket hole jig for strong invisible joints
• Glued dowels: Use doweling jig for precise alignment, very strong when done properly

For butt joints, you can use the measurements provided by the application as is.
\n\n
DADOS:
\n
• Use 1/8" dados for shelves into vertical dividers (leaves ~1/2" material)
• Use 1/4" dados for top/bottom/sides into end pieces (leaves 1/2" material)

For dados, you will have to adjust the part dimensions according to the dado depth above. (e.g. shelves that go into vertical dividers on 
either side will add 1/8" to either side)`
  
  // Split text into lines and render
  const assemblyLines = assemblyText.split('\n');
  for (const line of assemblyLines) {
    if (line.trim() === '') {
      yPos -= 8;
      continue;
    }
    
    let fontSize = 11;
    let font = helveticaFont;
    
    if (line.includes(':') && line.toUpperCase() === line) {
      fontSize = 12;
      font = helveticaBoldFont;
    }
    
    page4.drawText(line, {
      x: margin,
      y: yPos,
      size: fontSize,
      font: font,
    });
    yPos -= 16;
  }

  // ===== PAGE 4: Cut List =====
  const layoutResult = generateSheetLayouts(parts, params);
  const sheetSvgs = generateAllSheetSvgs(layoutResult.sheets, params);
  const oversizedSvgs = generateOversizedPartSvgs(layoutResult.oversizedParts, params);
  
  // Calculate total pages needed (regular sheets + oversized parts sections)
  const sheetsPerPage = 3;
  const regularSheetPages = Math.ceil(sheetSvgs.length / sheetsPerPage);
  
  // Process regular sheet pages first
  for (let pageIndex = 0; pageIndex < regularSheetPages; pageIndex++) {
    const page5 = addPage();
    yPos = pageHeight - margin;
    
    // Header
    page5.drawText('Cut List', {
      x: margin,
      y: yPos,
      size: 20,
      font: helveticaBoldFont,
    });
    yPos -= 25;
    
    // Body text with warning combined
    const sheetSize = params.unitSystem === 'metric' ? '1200mm x 2400mm' : '4\' x 8\'';
    const maxRip = params.unitSystem === 'metric' ? '610mm' : '24"';
    const spacing = params.unitSystem === 'metric' ? '20mm' : '1"';
    const bodyText = `Suggestion for organizing cuts on ${sheetSize} plywood sheet goods. The packing algorithm used here is very basic, and should be double-checked. I used ${maxRip} as a max rip width where possible. Lastly, the packing algorithm puts ${spacing} in between cuts - this is to avoid overpacking sheets, not to actually suggest you should put ${spacing} in between cuts.`;
    yPos -= 25;
    
    // Wrap body text (handles line breaks)
    const textLines: string[] = [];
    const paragraphs = bodyText.split('\n\n');
    
    for (const paragraph of paragraphs) {
      if (paragraph.trim() === '') {
        textLines.push(''); // Empty line for spacing
        continue;
      }
      
      const words = paragraph.split(' ');
      let currentLine = '';
      
      for (const word of words) {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        if (testLine.length * 5 > contentWidth) {
          if (currentLine) textLines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) textLines.push(currentLine);
      textLines.push(''); // Add spacing between paragraphs
    }
    
    for (const line of textLines) {
      if (line === '') {
        yPos -= 6; // Spacing for empty lines
      } else {
        page5.drawText(line, {
          x: margin,
          y: yPos,
          size: 11,
          font: helveticaFont,
          color: rgb(0, 0, 0), // Ensure black text
        });
        yPos -= 14;
      }
    }
    
    yPos -= 20;
    
    // Note about dimensions
    page5.drawText('**Note - these dimensions may change depending on your preferred assembly method!! See previous section**', {
      x: margin,
      y: yPos,
      size: 10,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
    yPos -= 30;
    
    // Embed sheet images (50% of remaining height, organized side by side)
    const availableHeight = yPos - margin;
    const imageHeight = availableHeight * 0.5;
    const startIndex = pageIndex * sheetsPerPage;
    const endIndex = Math.min(startIndex + sheetsPerPage, sheetSvgs.length);
    
    let currentX = margin + 30; // Start with some left padding to center sheets
    
    for (let i = startIndex; i < endIndex; i++) {
      try {
        const pngBytes = await svgToPng(sheetSvgs[i], {
          width: 280, // Tight around 4:8 ratio content + minimal margins
          height: 500, // Includes title space and dimension space
          scale: 2
        });
        
        const pngImage = await pdfDoc.embedPng(pngBytes);
        const scaledDims = pngImage.scale(imageHeight / 500);
        
        page5.drawImage(pngImage, {
          x: currentX,
          y: yPos - scaledDims.height,
          width: scaledDims.width,
          height: scaledDims.height,
        });
        
        currentX += scaledDims.width;
        
      } catch (error) {
        console.warn(`Failed to embed sheet ${i}:`, error);
        
        // Fallback placeholder - use reasonable dimensions
        const fallbackWidth = 200;
        
        page3.drawRectangle({
          x: currentX,
          y: yPos - imageHeight,
          width: fallbackWidth,
          height: imageHeight,
          borderColor: rgb(0.8, 0.8, 0.8),
          borderWidth: 1,
        });
        
        page5.drawText('Sheet diagram unavailable', {
          x: currentX + fallbackWidth/2 - 60,
          y: yPos - imageHeight/2,
          size: 10,
          font: helveticaFont,
          color: rgb(0.6, 0.6, 0.6),
        });
        
        currentX += fallbackWidth;
      }
    }
  }
  
  // ===== Oversized Parts Page (if any) =====
  if (layoutResult.oversizedParts.length > 0) {
    const oversizedPage = addPage();
    yPos = pageHeight - margin;
    
    // Header
    oversizedPage.drawText('Cut List', {
      x: margin,
      y: yPos,
      size: 20,
      font: helveticaBoldFont,
    });
    yPos -= 40;
    
    // "Does Not Fit" section title
    oversizedPage.drawText('Parts That Do Not Fit Standard Sheets', {
      x: margin,
      y: yPos,
      size: 16,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
    yPos -= 25;
    
    // Explanation text
    const sheetDimensions = params.unitSystem === 'metric' ? '1200mm × 2400mm' : '4\' × 8\'';
    const explanationText = `The following parts exceed the dimensions of standard ${sheetDimensions} plywood sheets and will need to be sourced separately or assembled from multiple pieces:`;
    
    // Wrap explanation text
    const words = explanationText.split(' ');
    let currentLine = '';
    const textLines: string[] = [];
    
    for (const word of words) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word;
      if (testLine.length * 6 > contentWidth) {
        if (currentLine) textLines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    if (currentLine) textLines.push(currentLine);
    
    for (const line of textLines) {
      oversizedPage.drawText(line, {
        x: margin,
        y: yPos,
        size: 11,
        font: helveticaFont,
        color: rgb(0, 0, 0),
      });
      yPos -= 14;
    }
    yPos -= 20;
    
    // Display oversized parts with simplified images and text
    const partsPerRow = 2;
    const partImageWidth = (contentWidth - 40) / partsPerRow; // Some spacing between images
    const partImageHeight = 120;
    
    for (let i = 0; i < layoutResult.oversizedParts.length; i++) {
      const oversizedPart = layoutResult.oversizedParts[i];
      const row = Math.floor(i / partsPerRow);
      const col = i % partsPerRow;
      
      const partX = margin + col * (partImageWidth + 20);
      const partY = yPos - (row * (partImageHeight + 80)) - partImageHeight;
      
      // Check if we need a new page
      if (partY < margin + 60) {
        // Start new page if needed
        const newOversizedPage = addPage();
        yPos = pageHeight - margin - 40; // Reset Y position
        // Recalculate position for new page
        const newPartY = yPos - partImageHeight;
        
        // Use the new page and position
        await renderOversizedPart(newOversizedPage, partX, newPartY, oversizedPart, partImageWidth, partImageHeight, i);
      } else {
        await renderOversizedPart(oversizedPage, partX, partY, oversizedPart, partImageWidth, partImageHeight, i);
      }
    }
  }
  
  // Helper function to render an oversized part
  async function renderOversizedPart(page: any, x: number, y: number, oversizedPart: any, width: number, height: number, index: number) {
    const part = oversizedPart.part;
    
    try {
      // Calculate proper dimensions based on part's actual aspect ratio
      const partAspectRatio = part.widthIn / part.lengthIn;
      const availableAspectRatio = width / height;
      
      let imageWidth, imageHeight;
      if (partAspectRatio > availableAspectRatio) {
        // Part is wider relative to available space - limit by width
        imageWidth = width;
        imageHeight = width / partAspectRatio;
      } else {
        // Part is taller relative to available space - limit by height
        imageHeight = height;
        imageWidth = height * partAspectRatio;
      }
      
      // Generate and embed the simplified SVG with natural aspect ratio
      const pngBytes = await svgToPng(oversizedSvgs[index], {
        width: Math.round(imageWidth * 2), // 2x for better quality
        height: Math.round(imageHeight * 2),
        scale: 1
      });
      
      const pngImage = await pdfDoc.embedPng(pngBytes);
      
      // Center the image in the available space
      const imageX = x + (width - imageWidth) / 2;
      const imageY = y + (height - imageHeight) / 2;
      
      page.drawImage(pngImage, {
        x: imageX,
        y: imageY,
        width: imageWidth,
        height: imageHeight,
      });
      
    } catch (error) {
      console.warn('Failed to embed oversized part image:', error);
      
      // Fallback: simple rectangle
      page.drawRectangle({
        x: x + width/4,
        y: y + height/4,
        width: width/2,
        height: height/2,
        borderColor: rgb(0.8, 0.8, 0.8),
        borderWidth: 1,
      });
    }
    
    // Part details text below image
    const textY = y - 20;
    
    // Center text manually
    const partIdText = `${part.id}`;
    const partIdWidth = helveticaBoldFont.widthOfTextAtSize(partIdText, 12);
    page.drawText(partIdText, {
      x: x + (width - partIdWidth) / 2,
      y: textY,
      size: 12,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
    
    const dimensionText = params.unitSystem === 'metric'
      ? `${Math.round(part.widthIn * 25.4)}mm × ${Math.round(part.lengthIn * 25.4)}mm × ${Math.round(part.thicknessIn * 25.4)}mm`
      : `${part.widthIn.toFixed(2)}" × ${part.lengthIn.toFixed(2)}" × ${part.thicknessIn.toFixed(3)}"`;
    const dimensionWidth = helveticaFont.widthOfTextAtSize(dimensionText, 10);
    page.drawText(dimensionText, {
      x: x + (width - dimensionWidth) / 2,
      y: textY - 15,
      size: 10,
      font: helveticaFont,
      color: rgb(0.3, 0.3, 0.3),
    });
    
    const reasonText = `Reason: ${oversizedPart.reason}`;
    const reasonWidth = helveticaFont.widthOfTextAtSize(reasonText, 9);
    page.drawText(reasonText, {
      x: x + (width - reasonWidth) / 2,
      y: textY - 30,
      size: 9,
      font: helveticaFont,
      color: rgb(0.6, 0, 0),
    });
  }

  // ===== ASSEMBLY GUIDE PAGES =====
  const assemblyGuideSvgs = generateAllAssemblyGuideSvgs(parts, params);

  if (assemblyGuideSvgs.length > 0) {
    // Group by role
    const groups: { [role: string]: typeof assemblyGuideSvgs } = {
      'Top/Bottom': [],
      'Sides': [],
      'Vertical Dividers': [],
      'Shelves': [],
    };

    for (const item of assemblyGuideSvgs) {
      if (item.role === 'Top' || item.role === 'Bottom') {
        groups['Top/Bottom'].push(item);
      } else if (item.role === 'Side') {
        groups['Sides'].push(item);
      } else if (item.role === 'VerticalDivider') {
        groups['Vertical Dividers'].push(item);
      } else if (item.role === 'BayShelf') {
        groups['Shelves'].push(item);
      }
    }

    // Helper to add assembly guide page header
    const addAssemblyPageHeader = (page: any) => {
      let headerY = pageHeight - margin;
      page.drawText('Assembly Guide', {
        x: margin,
        y: headerY,
        size: 20,
        font: helveticaBoldFont,
      });
      headerY -= 30;

      page.drawText('Joint locations for frame pieces. Note: This may not perform well for pieces with merges. Always double check dims.', {
        x: margin,
        y: headerY,
        size: 14,
        font: helveticaFont,
        color: rgb(0.3, 0.3, 0.3),
      });
      return headerY - 40; // Return Y position after header
    };

    // Start first assembly guide page
    let assemblyPage = addPage();
    let currentY = addAssemblyPageHeader(assemblyPage);

    // Render each group
    for (const [groupName, items] of Object.entries(groups)) {
      if (items.length === 0) continue;

      // Check if we need a new page for this group header
      if (currentY < margin + 100) {
        assemblyPage = addPage();
        currentY = addAssemblyPageHeader(assemblyPage);
      }

      // Group title
      assemblyPage.drawText(groupName, {
        x: margin,
        y: currentY,
        size: 14,
        font: helveticaBoldFont,
        color: rgb(0, 0, 0),
      });
      currentY -= 25;

      // Render parts in this group
      let currentX = margin;
      const imagesPerRow = 2;
      let imagesInRow = 0;
      const imageMaxWidth = (contentWidth - 40) / imagesPerRow;
      const imageMaxHeight = 160;

      for (const item of items) {
        try {
          // Parse SVG to get dimensions
          const widthMatch = item.svg.match(/width="([0-9.]+)"/);
          const heightMatch = item.svg.match(/height="([0-9.]+)"/);

          if (!widthMatch || !heightMatch) continue;

          const svgWidth = parseFloat(widthMatch[1]);
          const svgHeight = parseFloat(heightMatch[1]);

          // Calculate scaled dimensions to fit in available space
          const aspectRatio = svgWidth / svgHeight;
          let imageWidth = imageMaxWidth;
          let imageHeight = imageMaxWidth / aspectRatio;

          if (imageHeight > imageMaxHeight) {
            imageHeight = imageMaxHeight;
            imageWidth = imageMaxHeight * aspectRatio;
          }

          // Check if we need a new row
          if (imagesInRow >= imagesPerRow) {
            currentX = margin;
            currentY -= imageMaxHeight + 10;
            imagesInRow = 0;
          }

          // Check if we need a new page (check before placing image)
          if (currentY - imageHeight < margin) {
            assemblyPage = addPage();
            currentY = addAssemblyPageHeader(assemblyPage);

            // Repeat group title on new page
            assemblyPage.drawText(`${groupName} (continued)`, {
              x: margin,
              y: currentY,
              size: 14,
              font: helveticaBoldFont,
              color: rgb(0, 0, 0),
            });
            currentY -= 25;
            currentX = margin;
            imagesInRow = 0;
          }

          // Convert SVG to PNG and embed
          const pngBytes = await svgToPng(item.svg, {
            width: Math.round(svgWidth * 2), // 2x for quality
            height: Math.round(svgHeight * 2),
            scale: 1,
          });

          const pngImage = await pdfDoc.embedPng(pngBytes);

          assemblyPage.drawImage(pngImage, {
            x: currentX,
            y: currentY - imageHeight,
            width: imageWidth,
            height: imageHeight,
          });

          currentX += imageMaxWidth + 20;
          imagesInRow++;

        } catch (error) {
          console.warn(`Failed to embed assembly guide for ${item.partId}:`, error);
        }
      }

      // Move to next group (add spacing after the last row of this group)
      if (imagesInRow > 0) {
        currentY -= imageMaxHeight + 20; // Extra space between groups
      }
    }
  }

  // ===== PAGE N: Thank You =====
  const thankYouPage = addPage();
  yPos = pageHeight - margin;

  // Header
  thankYouPage.drawText('Notes', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 60;

  // Body
  thankYouPage.drawText('This instruction set was generated from adamvosburgh.github.io/kallax-configurator. \nMore info about the project can be found there. If you have any images to share of what you build, send them to me at adamvosburgh@gmail.com.\nIf you have any ideas for improvement, feel free to fork the repo on github and submit a pull request with your change.', {
    x: margin,
    y: yPos,
    size: 12,
    font: helveticaFont,
    maxWidth: contentWidth,
  });

  const pdfBytes = await pdfDoc.save();
  return pdfBytes;
}