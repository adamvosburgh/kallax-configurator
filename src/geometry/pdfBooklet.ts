import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import type { Part, DesignParams } from './types';
import { generateAssemblySteps } from './svgDiagrams';
import { toFraction32, formatDimensions } from './format';
import { calculateDimensions } from './layout';
import { svgToPng, getSvgDimensions } from '../lib/svgToImage';
import { generateSheetLayouts } from './ripGenerator';
import { generateAllSheetSvgs, generateOversizedPartSvgs } from './cutListSvg';
import { generateGridSvg } from './gridSvg';

export async function generatePDFBooklet(
  parts: Part[], 
  params: DesignParams,
  title: string = 'Custom Modular Shelving'
): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  const dimensions = calculateDimensions(params);
  
  // Page dimensions (Landscape Letter: 11" x 8.5")
  const pageWidth = 792;
  const pageHeight = 612;
  const margin = 40;
  const contentWidth = pageWidth - 2 * margin;
  const contentHeight = pageHeight - 2 * margin;
  
  // Helper function to add a page
  const addPage = () => pdfDoc.addPage([pageWidth, pageHeight]);
  
  // Helper function to get site URL (placeholder for now)
  const siteUrl = 'kallax-configurator.app'; // TODO: Get from config
  
  // Helper function to get door configuration description
  const getDoorDescription = () => {
    if (!params.hasDoors) return 'no doors';
    if (params.doorMode.type === 'inset') return 'inset doors';
    return 'overlay doors';
  };
  
  // Helper function to get back description
  const getBackDescription = () => params.hasBack ? 'back' : 'no back';
  
  // ===== PAGE 1: Title Page =====
  const page1 = addPage();
  let yPos = pageHeight - margin;
  
  // Header
  page1.drawText(title, {
    x: margin,
    y: yPos,
    size: 24,
    font: helveticaBoldFont,
    color: rgb(0, 0, 0),
  });
  yPos -= 30;
  
  page1.drawText(`${params.cols} x ${params.rows} with ${getBackDescription()} and ${getDoorDescription()}`, {
    x: margin,
    y: yPos,
    size: 16,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  
  // Body - ikea-guy (right-aligned with header)
  const ikeaGuySize = 80;
  const ikeaGuyX = pageWidth - margin - ikeaGuySize;
  const ikeaGuyY = pageHeight - margin - ikeaGuySize - 10;
  
  // Load and embed IKEA guy image
  try {
    const ikeaGuyBytes = await fetch('/src/assets/ikea-guy.jpg').then(res => res.arrayBuffer());
    const ikeaGuyImage = await pdfDoc.embedJpg(ikeaGuyBytes);
    const ikeaGuyDims = ikeaGuyImage.scale(ikeaGuySize / Math.max(ikeaGuyImage.width, ikeaGuyImage.height));
    
    page1.drawImage(ikeaGuyImage, {
      x: ikeaGuyX,
      y: ikeaGuyY,
      width: ikeaGuyDims.width,
      height: ikeaGuyDims.height,
    });
  } catch (error) {
    console.warn('Failed to load IKEA guy image:', error);
    // Fallback placeholder
    page1.drawRectangle({
      x: ikeaGuyX,
      y: ikeaGuyY,
      width: ikeaGuySize,
      height: ikeaGuySize,
      borderColor: rgb(0.8, 0.8, 0.8),
      borderWidth: 1,
    });
    page1.drawText('IKEA Guy', {
      x: ikeaGuyX + ikeaGuySize/2 - 25,
      y: ikeaGuyY + ikeaGuySize/2,
      size: 10,
      font: helveticaFont,
      color: rgb(0.6, 0.6, 0.6),
    });
  }
  
  // Body text (left-aligned)
  yPos = pageHeight - margin - 80;
  const bodyText = `Overview for assembling a plywood modular shelving unit generated by ${siteUrl}. Note that this app does not generate detailed assembly instructions, but will give you an overview of your options.`;
  
  // Wrap text to 300px width (left column)
  const leftColumnWidth = 300;
  const words = bodyText.split(' ');
  let currentLine = '';
  const lines: string[] = [];
  
  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const textWidth = helveticaFont.widthOfTextAtSize(testLine, 12);
    
    if (textWidth > leftColumnWidth && currentLine) {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) lines.push(currentLine);
  
  for (const line of lines) {
    page1.drawText(line, {
      x: margin,
      y: yPos,
      size: 12,
      font: helveticaFont,
    });
    yPos -= 16;
  }
  
  // Axonometric view (right-aligned, majority space)
  const imageWidth = 350;
  const imageHeight = 350;
  const imageX = pageWidth - margin - imageWidth;
  const imageY = yPos - imageHeight;
  
  // TODO: Generate and embed axonometric view
  // For now, showing placeholder
  page1.drawRectangle({
    x: imageX,
    y: imageY,
    width: imageWidth,
    height: imageHeight,
    borderColor: rgb(0.8, 0.8, 0.8),
    borderWidth: 1,
  });
  page1.drawText('Axonometric View\n(To be implemented)', {
    x: imageX + imageWidth/2 - 70,
    y: imageY + imageHeight/2,
    size: 12,
    font: helveticaFont,
    color: rgb(0.6, 0.6, 0.6),
  });
  
  // Dimensions
  page1.drawText(`Width: ${toFraction32(dimensions.extWidth)}"`, {
    x: imageX,
    y: imageY - 20,
    size: 10,
    font: helveticaFont,
  });
  page1.drawText(`Height: ${toFraction32(dimensions.extHeight)}"`, {
    x: imageX,
    y: imageY - 35,
    size: 10,
    font: helveticaFont,
  });
  page1.drawText(`Depth: ${toFraction32(dimensions.extDepth)}"`, {
    x: imageX,
    y: imageY - 50,
    size: 10,
    font: helveticaFont,
  });
  
  // ===== PAGE 2: Configurations + Pieces =====
  const page2 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page2.drawText('Configurations + Pieces', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 25;
  
  page2.drawText('Configurations set by user, and tabulated cut list', {
    x: margin,
    y: yPos,
    size: 14,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  yPos -= 40;
  
  // Grid Configuration and Layout (left side)
  try {
    const gridSvg = generateGridSvg(params);
    const gridPngBytes = await svgToPng(gridSvg, {
      width: 100,
      height: 100,
      scale: 1
    });
    
    const gridImage = await pdfDoc.embedPng(gridPngBytes);
    const gridDims = gridImage.scale(1);
    
    page2.drawImage(gridImage, {
      x: margin,
      y: yPos - gridDims.height,
      width: gridDims.width,
      height: gridDims.height,
    });
  } catch (error) {
    console.warn('Failed to embed grid SVG:', error);
    // Fallback placeholder
    page2.drawRectangle({
      x: margin,
      y: yPos - 150,
      width: 200,
      height: 150,
      borderColor: rgb(0.8, 0.8, 0.8),
      borderWidth: 1,
    });
  }
  
  // Chart 1: All Configurations (right side)
  const configX = margin + 250;
  let configY = yPos;
  
  page2.drawText('Configuration:', {
    x: configX,
    y: configY,
    size: 12,
    font: helveticaBoldFont,
  });
  configY -= 20;
  
  const configs = [
    `Grid Layout: ${params.rows} rows × ${params.cols} columns`,
    `Module Size: ${toFraction32(params.interiorClearanceInches)}"`,
    `Depth: ${toFraction32(params.depthInches)}"`,
    `Back Panel: ${params.hasBack ? 'Yes' : 'No'}`,
    `Doors: ${params.hasDoors ? 'Yes' : 'No'}`,
    `Frame Thickness: ${params.materials.frame.nominal}`,
  ];
  
  if (params.hasBack && params.materials.back) {
    configs.push(`Back Thickness: ${params.materials.back.nominal}`);
  }
  
  if (params.hasDoors && params.materials.door) {
    configs.push(`Door Thickness: ${params.materials.door.nominal}`);
    configs.push(`Door Style: ${params.doorMode.type}`);
    if (params.doorMode.type === 'inset') {
      configs.push(`Door Reveal: ${toFraction32(params.doorMode.revealInches || 0.0625)}"`);
    } else {
      configs.push(`Door Overlay: ${toFraction32(params.doorMode.overlayInches || 0.25)}"`);
    }
  }
  
  for (const config of configs) {
    page2.drawText(`• ${config}`, {
      x: configX,
      y: configY,
      size: 10,
      font: helveticaFont,
    });
    configY -= 15;
  }
  
  // Chart 2: Parts List (bottom half)
  configY = yPos - 200;
  page2.drawText('Parts List:', {
    x: margin,
    y: configY,
    size: 12,
    font: helveticaBoldFont,
  });
  configY -= 20;
  
  // Parts table header
  page2.drawText('Part ID', { x: margin, y: configY, size: 9, font: helveticaBoldFont });
  page2.drawText('Role', { x: margin + 100, y: configY, size: 9, font: helveticaBoldFont });
  page2.drawText('Qty', { x: margin + 180, y: configY, size: 9, font: helveticaBoldFont });
  page2.drawText('Dimensions', { x: margin + 210, y: configY, size: 9, font: helveticaBoldFont });
  page2.drawText('Notes', { x: margin + 350, y: configY, size: 9, font: helveticaBoldFont });
  
  configY -= 15;
  page2.drawLine({
    start: { x: margin, y: configY },
    end: { x: pageWidth - margin, y: configY },
    thickness: 1,
    color: rgb(0, 0, 0),
  });
  configY -= 10;
  
  // List parts (limited to available space)
  for (let i = 0; i < parts.length && configY > margin + 30; i++) {
    const part = parts[i];
    page2.drawText(part.id, { x: margin, y: configY, size: 8, font: helveticaFont });
    page2.drawText(part.role, { x: margin + 100, y: configY, size: 8, font: helveticaFont });
    page2.drawText(part.qty.toString(), { x: margin + 180, y: configY, size: 8, font: helveticaFont });
    page2.drawText(formatDimensions(part.lengthIn, part.widthIn, part.thicknessIn), { 
      x: margin + 210, y: configY, size: 8, font: helveticaFont 
    });
    
    if (part.notes) {
      const notes = part.notes.length > 30 ? part.notes.substring(0, 27) + '...' : part.notes;
      page2.drawText(notes, { 
        x: margin + 350, y: configY, size: 7, font: helveticaFont, color: rgb(0.4, 0.4, 0.4)
      });
    }
    
    configY -= 12;
  }
  
  // ===== PAGE 3: Cut List =====
  const layoutResult = generateSheetLayouts(parts);
  const sheetSvgs = generateAllSheetSvgs(layoutResult.sheets);
  
  // Group sheets by pages (3 per page)
  const sheetsPerPage = 3;
  for (let pageIndex = 0; pageIndex < Math.ceil(sheetSvgs.length / sheetsPerPage); pageIndex++) {
    const page3 = addPage();
    yPos = pageHeight - margin;
    
    // Header
    page3.drawText('Cut List', {
      x: margin,
      y: yPos,
      size: 20,
      font: helveticaBoldFont,
    });
    yPos -= 25;
    
    page3.drawText('Suggestion for organizing cuts on 4\' x 8\' plywood sheet goods', {
      x: margin,
      y: yPos,
      size: 14,
      font: helveticaFont,
      color: rgb(0.3, 0.3, 0.3),
    });
    yPos -= 40;
    
    // Warning text
    const warningText = 'These drawings are suggestions for how one may lay out the parts on 4\' x 8\' sheet to minimize material waste. The packing algorithm used here is very basic, and should be double-checked. To try to plan for max rip lengths of various equipment - pieces with both dims below 24" are organized by their largest dim, and pieces with a dim above 24" are organized by their smallest. Lastly, the packing algorithm puts 1" in between cuts - this is so the user does not end up with small pieces due to the kerf of the blade, not to actually suggest you should put 1" in between cuts.';
    
    // Wrap warning text
    const warningLines: string[] = [];
    const warningWords = warningText.split(' ');
    let currentWarningLine = '';
    
    for (const word of warningWords) {
      const testLine = currentWarningLine + (currentWarningLine ? ' ' : '') + word;
      if (testLine.length * 5 > contentWidth) {
        if (currentWarningLine) warningLines.push(currentWarningLine);
        currentWarningLine = word;
      } else {
        currentWarningLine = testLine;
      }
    }
    if (currentWarningLine) warningLines.push(currentWarningLine);
    
    for (const line of warningLines) {
      page3.drawText(line, {
        x: margin,
        y: yPos,
        size: 10,
        font: helveticaFont,
      });
      yPos -= 12;
    }
    
    yPos -= 20;
    
    // Note about dimensions
    page3.drawText('**Note - these dimensions may change depending on your preferred assembly method!! See next section**', {
      x: margin,
      y: yPos,
      size: 10,
      font: helveticaBoldFont,
      color: rgb(0.8, 0, 0),
    });
    yPos -= 30;
    
    // Embed sheet images (50% of remaining height, organized side by side)
    const availableHeight = yPos - margin;
    const imageHeight = availableHeight * 0.5;
    const startIndex = pageIndex * sheetsPerPage;
    const endIndex = Math.min(startIndex + sheetsPerPage, sheetSvgs.length);
    
    let currentX = margin;
    
    for (let i = startIndex; i < endIndex; i++) {
      try {
        const pngBytes = await svgToPng(sheetSvgs[i], {
          width: 210, // Tight around 4:8 ratio content + minimal margins
          height: 465, // Includes title space and dimension space
          scale: 2
        });
        
        const pngImage = await pdfDoc.embedPng(pngBytes);
        const scaledDims = pngImage.scale(imageHeight / 465);
        
        page3.drawImage(pngImage, {
          x: currentX,
          y: yPos - scaledDims.height,
          width: scaledDims.width,
          height: scaledDims.height,
        });
        
        currentX += scaledDims.width;
        
      } catch (error) {
        console.warn(`Failed to embed sheet ${i}:`, error);
        
        // Fallback placeholder - use reasonable dimensions
        const fallbackWidth = 200;
        
        page3.drawRectangle({
          x: currentX,
          y: yPos - imageHeight,
          width: fallbackWidth,
          height: imageHeight,
          borderColor: rgb(0.8, 0.8, 0.8),
          borderWidth: 1,
        });
        
        page3.drawText('Sheet diagram unavailable', {
          x: currentX + fallbackWidth/2 - 60,
          y: yPos - imageHeight/2,
          size: 10,
          font: helveticaFont,
          color: rgb(0.6, 0.6, 0.6),
        });
        
        currentX += fallbackWidth;
      }
    }
  }
  
  // Add oversized parts section if there are any
  if (layoutResult.oversizedParts.length > 0) {
    const oversizedSvgs = generateOversizedPartSvgs(layoutResult.oversizedParts);
    
    // Group oversized parts by pages (3 per page, same as sheets)
    const oversizedPerPage = 3;
    for (let pageIndex = 0; pageIndex < Math.ceil(oversizedSvgs.length / oversizedPerPage); pageIndex++) {
      const oversizedPage = addPage();
      yPos = pageHeight - margin;
      
      // Header
      oversizedPage.drawText('Parts That Do Not Fit Standard Sheets', {
        x: margin,
        y: yPos,
        size: 20,
        font: helveticaBoldFont,
        color: rgb(0.8, 0, 0),
      });
      
      oversizedPage.drawText('The following parts exceed 4\' × 8\' plywood dimensions:', {
        x: margin,
        y: yPos - 25,
        size: 12,
        font: helveticaFont,
        color: rgb(0.3, 0.3, 0.3),
      });
      
      yPos -= 60;
      const imageHeight = 300; // Height for oversized part images
      let currentX = margin;
      
      const startIndex = pageIndex * oversizedPerPage;
      const endIndex = Math.min(startIndex + oversizedPerPage, oversizedSvgs.length);
      
      for (let i = startIndex; i < endIndex; i++) {
        try {
          // Get SVG dimensions for proper scaling
          const svgDims = getSvgDimensions(oversizedSvgs[i]);
          
          const pngBytes = await svgToPng(oversizedSvgs[i], {
            width: svgDims.width,
            height: svgDims.height,
            scale: 2
          });
          
          const pngImage = await pdfDoc.embedPng(pngBytes);
          const scaledDims = pngImage.scale(imageHeight / svgDims.height);
          
          oversizedPage.drawImage(pngImage, {
            x: currentX,
            y: yPos - scaledDims.height,
            width: scaledDims.width,
            height: scaledDims.height,
          });
          
          currentX += scaledDims.width + 20; // Small spacing between parts
        } catch (error) {
          console.warn(`Failed to embed oversized part ${i}:`, error);
          
          // Fallback placeholder
          const fallbackWidth = 150;
          
          oversizedPage.drawRectangle({
            x: currentX,
            y: yPos - imageHeight,
            width: fallbackWidth,
            height: imageHeight,
            borderColor: rgb(0.8, 0, 0),
            borderWidth: 1,
          });
          
          oversizedPage.drawText('Part diagram unavailable', {
            x: currentX + fallbackWidth/2 - 60,
            y: yPos - imageHeight/2,
            size: 10,
            font: helveticaFont,
            color: rgb(0.6, 0, 0),
          });
          
          currentX += fallbackWidth + 20;
        }
      }
    }
  }
  
  // ===== PAGE 4: Connections and Assembly Methods =====
  const page4 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page4.drawText('Connections and Assembly Methods', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 25;
  
  page4.drawText('Suggestions for how to assemble', {
    x: margin,
    y: yPos,
    size: 14,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  yPos -= 40;
  
  // Assembly methods content
  const assemblyText = `For 3/4" plywood modular shelving, consider these assembly methods:

DADOS:
• Use 1/8" dados for shelves into vertical dividers (leaves ~1/2" material)
• Use 1/4" dados for top/bottom/sides into end pieces (leaves 1/2" material)
• Remember to adjust part dimensions to account for how parts sit into dados

BUTT JOINTS:
• Hidden screws: Pre-drill and countersink, use wood plugs to hide screw heads
• Pocket screws: Use pocket hole jig for strong invisible joints
• Glued dowels: Use doweling jig for precise alignment, very strong when done properly

Choose your method based on your tools, skill level, and desired appearance.`;
  
  // Split text into lines and render
  const assemblyLines = assemblyText.split('\n');
  for (const line of assemblyLines) {
    if (line.trim() === '') {
      yPos -= 8;
      continue;
    }
    
    let fontSize = 11;
    let font = helveticaFont;
    
    if (line.includes(':') && line.toUpperCase() === line) {
      fontSize = 12;
      font = helveticaBoldFont;
    }
    
    page4.drawText(line, {
      x: margin,
      y: yPos,
      size: fontSize,
      font: font,
    });
    yPos -= 16;
  }
  
  // ===== PAGE 5: Thank You =====
  const page5 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page5.drawText('Thank you!', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 60;
  
  // Body
  page5.drawText('Hope this helps. If you have any images to share of what you build, send them to me at adamvosburgh@gmail.com!', {
    x: margin,
    y: yPos,
    size: 14,
    font: helveticaFont,
  });
  
  const pdfBytes = await pdfDoc.save();
  return pdfBytes;
}