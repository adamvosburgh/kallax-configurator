import { PDFDocument, rgb, StandardFonts } from 'pdf-lib';
import type { Part, DesignParams } from './types';
import { toFraction32, formatDimensions } from './format';
import { svgToPng } from '../lib/svgToImage';
import { generateSheetLayouts } from './ripGenerator';
import { generateAllSheetSvgs, generateOversizedPartSvgs } from './cutListSvg';
import { captureAxonometricView } from './sceneCapture';

export async function generatePDFBooklet(
  parts: Part[], 
  params: DesignParams,
  title: string = 'Custom Modular Shelving'
): Promise<Uint8Array> {
  const pdfDoc = await PDFDocument.create();
  const helveticaFont = await pdfDoc.embedFont(StandardFonts.Helvetica);
  const helveticaBoldFont = await pdfDoc.embedFont(StandardFonts.HelveticaBold);
  
  
  // Page dimensions (Landscape Letter: 11" x 8.5")
  const pageWidth = 792;
  const pageHeight = 612;
  const margin = 40;
  const contentWidth = pageWidth - 2 * margin;
  
  // Helper function to add a page
  const addPage = () => pdfDoc.addPage([pageWidth, pageHeight]);
  
  // Helper function to get site URL (placeholder for now)
  const siteUrl = 'kallax-configurator.app'; // TODO: Get from config
  
  // Helper function to get door configuration description
  const getDoorDescription = () => {
    if (!params.hasDoors) return 'no doors';
    if (params.doorMode.type === 'inset') return 'inset doors';
    return 'overlay doors';
  };
  
  // Helper function to get back description
  const getBackDescription = () => params.hasBack ? 'back' : 'no back';
  
  // ===== PAGE 1: Title Page =====
  const page1 = addPage();
  let yPos = pageHeight - margin;
  
  // Header
  page1.drawText(title, {
    x: margin,
    y: yPos,
    size: 24,
    font: helveticaBoldFont,
    color: rgb(0, 0, 0),
  });
  yPos -= 30;
  
  page1.drawText(`${params.cols} x ${params.rows} with ${getBackDescription()} and ${getDoorDescription()}`, {
    x: margin,
    y: yPos,
    size: 16,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  
  
  yPos = pageHeight - margin - 80;
  const bodyText = `Overview for assembling a plywood modular shelving unit generated by ${siteUrl}. Note that this app does not generate detailed assembly instructions, but will give you an overview of your options.`;
  
  const leftColumnWidth = 600;
  const words = bodyText.split(' ');
  let currentLine = '';
  const lines: string[] = [];
  
  for (const word of words) {
    const testLine = currentLine ? `${currentLine} ${word}` : word;
    const textWidth = helveticaFont.widthOfTextAtSize(testLine, 12);
    
    if (textWidth > leftColumnWidth && currentLine) {
      lines.push(currentLine);
      currentLine = word;
    } else {
      currentLine = testLine;
    }
  }
  if (currentLine) lines.push(currentLine);
  
  for (const line of lines) {
    page1.drawText(line, {
      x: margin,
      y: yPos,
      size: 12,
      font: helveticaFont,
    });
    yPos -= 16;
  }
  
  // Axonometric view (centered, wider)
  const imageWidth = 450; // Wider
  const imageHeight = 350; // Keep same height
  const imageX = (pageWidth - imageWidth) / 2; // Centered
  const imageY = yPos - imageHeight;
  
  // Generate and embed axonometric view from 3D scene capture
  try {
    const axonometricBlob = await captureAxonometricView(
      params,
      Math.round(imageWidth * 2), // Higher resolution for better quality
      Math.round(imageHeight * 2)
    );
    
    const axonometricPngBytes = new Uint8Array(await axonometricBlob.arrayBuffer());
    const axonometricImage = await pdfDoc.embedPng(axonometricPngBytes);
    const scaledDims = axonometricImage.scale(Math.min(imageWidth / axonometricImage.width, imageHeight / axonometricImage.height));
    
    // Center the axonometric view
    const centeredX = imageX + (imageWidth - scaledDims.width) / 2;
    const centeredY = imageY + (imageHeight - scaledDims.height) / 2;
    
    page1.drawImage(axonometricImage, {
      x: centeredX,
      y: centeredY - 50,
      width: scaledDims.width,
      height: scaledDims.height,
    });
  } catch (error) {
    console.warn('Failed to generate axonometric view:', error);
    
    // Fallback placeholder
    page1.drawRectangle({
      x: imageX,
      y: imageY,
      width: imageWidth,
      height: imageHeight,
      borderColor: rgb(0.8, 0.8, 0.8),
      borderWidth: 1,
    });
    page1.drawText('Axonometric View\n(Generation failed)', {
      x: imageX + imageWidth/2 - 70,
      y: imageY + imageHeight/2,
      size: 12,
      font: helveticaFont,
      color: rgb(0.6, 0.6, 0.6),
    });
  }
  
  
  // ===== PAGE 2: Instruction Guys =====
  const page2 = addPage();
  
  try {
    // Load and embed instruction guys image scaled to 80% of page width, centered
    const instructionGuysBytes = await fetch('/src/assets/InstructionGuys.png').then(res => res.arrayBuffer());
    const instructionGuysImage = await pdfDoc.embedPng(instructionGuysBytes);
    
    // Scale to 80% of page width while maintaining aspect ratio
    const targetWidth = pageWidth * 0.8;
    const scale = targetWidth / instructionGuysImage.width;
    const scaledWidth = instructionGuysImage.width * scale;
    const scaledHeight = instructionGuysImage.height * scale;
    
    // Center the scaled image on the page
    const imageX = (pageWidth - scaledWidth) / 2;
    const imageY = (pageHeight - scaledHeight) / 2;
    
    page2.drawImage(instructionGuysImage, {
      x: imageX,
      y: imageY,
      width: scaledWidth,
      height: scaledHeight,
    });
  } catch (error) {
    console.warn('Failed to load instruction guys image:', error);
    // Fallback placeholder
    page2.drawText('Instruction Guys Image\n(Failed to load)', {
      x: pageWidth / 2 - 100,
      y: pageHeight / 2,
      size: 16,
      font: helveticaFont,
      color: rgb(0.6, 0.6, 0.6),
    });
  }
  
  // ===== PAGE 3: Configurations + Pieces =====
  const page3 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page3.drawText('Configurations + Pieces', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 25;
  
  page3.drawText('Configurations set by user, and tabulated cut list', {
    x: margin,
    y: yPos,
    size: 14,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  yPos -= 40;
  
  // Grid Configuration and Layout (drawn with native PDF vectors)
  const { rows, cols, merges } = params;
  const baseCellSize = 30; // Base cell size
  const strokeWidth = 1;
  const borderWidth = 2;
  
  // Calculate max dimensions based on 6x6 grid
  const maxGridHeight = 6 * baseCellSize + borderWidth * 2 - 20; // 164px
  const maxGridWidth = maxGridHeight + 100; // 264px
  
  // Calculate actual grid dimensions
  const naturalWidth = cols * baseCellSize + borderWidth * 2;
  const naturalHeight = rows * baseCellSize + borderWidth * 2;
  
  // Scale proportionally if needed
  const scaleX = naturalWidth > maxGridWidth ? maxGridWidth / naturalWidth : 1;
  const scaleY = naturalHeight > maxGridHeight ? maxGridHeight / naturalHeight : 1;
  const scale = Math.min(scaleX, scaleY);
  
  const cellSize = baseCellSize * scale;
  const gridWidth = naturalWidth * scale;
  const gridHeight = naturalHeight * scale;
  
  const gridX = margin;
  const gridY = yPos - gridHeight;
  
  // Helper function to check if a cell is part of a merge
  const getCellMerge = (row: number, col: number) => {
    return merges.find(merge =>
      row >= merge.r0 && row <= merge.r1 && col >= merge.c0 && col <= merge.c1
    ) || null;
  };
  
  // Helper function to check if a cell is the top-left origin of a merge
  const isMergeOrigin = (row: number, col: number, merge: any) => {
    return row === merge.r0 && col === merge.c0;
  };
  
  // Outer border (no fill, black stroke)
  page3.drawRectangle({
    x: gridX,
    y: gridY,
    width: gridWidth,
    height: gridHeight,
    borderColor: rgb(0, 0, 0),
    borderWidth: borderWidth,
  });
  
  // Generate cells
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const merge = getCellMerge(row, col);
      const isOrigin = merge && isMergeOrigin(row, col, merge);
      const isInMerge = merge && !isOrigin;
      
      // Don't render cells that are covered by a merge (except origin)
      if (isInMerge) continue;
      
      const cellX = gridX + borderWidth + col * cellSize;
      const cellY = gridY + borderWidth + row * cellSize;
      
      let cellWidth = cellSize;
      let cellHeight = cellSize;
      
      // Handle merged cells
      if (merge) {
        cellWidth = (merge.c1 - merge.c0 + 1) * cellSize;
        cellHeight = (merge.r1 - merge.r0 + 1) * cellSize;
      }
      
      // Cell rectangle (no fill, black stroke)
      page3.drawRectangle({
        x: cellX,
        y: cellY,
        width: cellWidth,
        height: cellHeight,
        borderColor: rgb(0, 0, 0),
        borderWidth: strokeWidth,
      });
      
      // Cell text
      const textX = cellX + cellWidth / 2;
      const textY = cellY + cellHeight / 2;
      
      if (merge) {
        page3.drawText(`${merge.c1 - merge.c0 + 1}×${merge.r1 - merge.r0 + 1}`, {
          x: textX - 10,
          y: textY - 5,
          size: 8,
          font: helveticaBoldFont,
          color: rgb(0, 0, 0),
        });
      } else {
        page3.drawText(`${row},${col}`, {
          x: textX - 8,
          y: textY - 3,
          size: 7,
          font: helveticaFont,
          color: rgb(0.4, 0.4, 0.4),
        });
      }
    }
  }
  
  // Chart 1: All Configurations (right side)
  const configX = margin + 250;
  let configY = yPos;
  
  page3.drawText('Configuration:', {
    x: configX,
    y: configY,
    size: 12,
    font: helveticaBoldFont,
  });
  configY -= 20;
  
  const configs = [
    `Grid Layout: ${params.rows} rows × ${params.cols} columns`,
    `Module Size: ${toFraction32(params.interiorClearanceInches)}"`,
    `Depth: ${toFraction32(params.depthInches)}"`,
    `Back Panel: ${params.hasBack ? 'Yes' : 'No'}`,
    `Doors: ${params.hasDoors ? 'Yes' : 'No'}`,
    `Frame Thickness: ${params.materials.frame.nominal}`,
  ];
  
  if (params.hasBack && params.materials.back) {
    configs.push(`Back Thickness: ${params.materials.back.nominal}`);
  }
  
  if (params.hasDoors && params.materials.door) {
    configs.push(`Door Thickness: ${params.materials.door.nominal}`);
    configs.push(`Door Style: ${params.doorMode.type}`);
    if (params.doorMode.type === 'inset') {
      configs.push(`Door Reveal: ${toFraction32(params.doorMode.revealInches || 0.0625)}"`);
    } else {
      configs.push(`Door Overlay: ${toFraction32(params.doorMode.overlayInches || 0.25)}"`);
    }
  }
  
  for (const config of configs) {
    page3.drawText(`• ${config}`, {
      x: configX,
      y: configY,
      size: 10,
      font: helveticaFont,
    });
    configY -= 15;
  }
  
  // Chart 2: Parts List (bottom half)
  configY = yPos - 200;
  page3.drawText('Parts List:', {
    x: margin,
    y: configY,
    size: 12,
    font: helveticaBoldFont,
  });
  configY -= 20;
  
  // Parts table header
  page3.drawText('Part ID', { x: margin, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Role', { x: margin + 100, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Qty', { x: margin + 180, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Dimensions', { x: margin + 210, y: configY, size: 9, font: helveticaBoldFont });
  page3.drawText('Notes', { x: margin + 350, y: configY, size: 9, font: helveticaBoldFont });
  
  configY -= 15;
  page3.drawLine({
    start: { x: margin, y: configY },
    end: { x: pageWidth - margin, y: configY },
    thickness: 1,
    color: rgb(0, 0, 0),
  });
  configY -= 10;
  
  // List parts (limited to available space)
  for (let i = 0; i < parts.length && configY > margin + 30; i++) {
    const part = parts[i];
    page3.drawText(part.id, { x: margin, y: configY, size: 8, font: helveticaFont });
    page3.drawText(part.role, { x: margin + 100, y: configY, size: 8, font: helveticaFont });
    page3.drawText(part.qty.toString(), { x: margin + 180, y: configY, size: 8, font: helveticaFont });
    page3.drawText(formatDimensions(part.lengthIn, part.widthIn, part.thicknessIn), { 
      x: margin + 210, y: configY, size: 8, font: helveticaFont 
    });
    
    if (part.notes) {
      const notes = part.notes.length > 100 ? part.notes.substring(0, 27) + '...' : part.notes;
      page3.drawText(notes, { 
        x: margin + 350, y: configY, size: 7, font: helveticaFont, color: rgb(0.4, 0.4, 0.4)
      });
    }
    
    configY -= 12;
  }
  
  // ===== PAGE 4: Connections and Assembly Methods =====
  const page4 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page4.drawText('Connections and Assembly Methods', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 25;
  
  page4.drawText('Suggestions for how to assemble', {
    x: margin,
    y: yPos,
    size: 14,
    font: helveticaFont,
    color: rgb(0.3, 0.3, 0.3),
  });
  yPos -= 40;
  
  // Assembly methods content
  const assemblyText = `For 3/4" plywood modular shelving, consider these assembly methods:

DADOS:
• Use 1/8" dados for shelves into vertical dividers (leaves ~1/2" material)
• Use 1/4" dados for top/bottom/sides into end pieces (leaves 1/2" material)
• Remember to adjust part dimensions to account for how parts sit into dados

BUTT JOINTS:
• Hidden screws: Pre-drill and countersink, use wood plugs to hide screw heads
• Pocket screws: Use pocket hole jig for strong invisible joints
• Glued dowels: Use doweling jig for precise alignment, very strong when done properly

Choose your method based on your tools, skill level, and desired appearance.`;
  
  // Split text into lines and render
  const assemblyLines = assemblyText.split('\n');
  for (const line of assemblyLines) {
    if (line.trim() === '') {
      yPos -= 8;
      continue;
    }
    
    let fontSize = 11;
    let font = helveticaFont;
    
    if (line.includes(':') && line.toUpperCase() === line) {
      fontSize = 12;
      font = helveticaBoldFont;
    }
    
    page4.drawText(line, {
      x: margin,
      y: yPos,
      size: fontSize,
      font: font,
    });
    yPos -= 16;
  }

  // ===== PAGE 4: Cut List =====
  const layoutResult = generateSheetLayouts(parts);
  const sheetSvgs = generateAllSheetSvgs(layoutResult.sheets);
  const oversizedSvgs = generateOversizedPartSvgs(layoutResult.oversizedParts);
  
  // Calculate total pages needed (regular sheets + oversized parts sections)
  const sheetsPerPage = 4;
  const regularSheetPages = Math.ceil(sheetSvgs.length / sheetsPerPage);
  
  // Process regular sheet pages first
  for (let pageIndex = 0; pageIndex < regularSheetPages; pageIndex++) {
    const page4 = addPage();
    yPos = pageHeight - margin;
    
    // Header
    page4.drawText('Cut List', {
      x: margin,
      y: yPos,
      size: 20,
      font: helveticaBoldFont,
    });
    yPos -= 25;
    
    // Body text with warning combined
    const bodyText = 'Suggestion for organizing cuts on 4\' x 8\' plywood sheet goods.\n\nThese drawings are suggestions for how one may lay out the parts on 4\' x 8\' sheet to minimize material waste. The packing algorithm used here is very basic, and should be double-checked. To try to plan for max rip lengths of various equipment - pieces with both dims below 24" are organized by their largest dim, and pieces with a dim above 24" are organized by their smallest. Lastly, the packing algorithm puts 1" in between cuts - this is so the user does not end up with small pieces due to the kerf of the blade, not to actually suggest you should put 1" in between cuts.';
    yPos -= 25;
    
    // Wrap body text (handles line breaks)
    const textLines: string[] = [];
    const paragraphs = bodyText.split('\n\n');
    
    for (const paragraph of paragraphs) {
      if (paragraph.trim() === '') {
        textLines.push(''); // Empty line for spacing
        continue;
      }
      
      const words = paragraph.split(' ');
      let currentLine = '';
      
      for (const word of words) {
        const testLine = currentLine + (currentLine ? ' ' : '') + word;
        if (testLine.length * 5 > contentWidth) {
          if (currentLine) textLines.push(currentLine);
          currentLine = word;
        } else {
          currentLine = testLine;
        }
      }
      if (currentLine) textLines.push(currentLine);
      textLines.push(''); // Add spacing between paragraphs
    }
    
    for (const line of textLines) {
      if (line === '') {
        yPos -= 6; // Spacing for empty lines
      } else {
        page4.drawText(line, {
          x: margin,
          y: yPos,
          size: 11,
          font: helveticaFont,
          color: rgb(0, 0, 0), // Ensure black text
        });
        yPos -= 14;
      }
    }
    
    yPos -= 20;
    
    // Note about dimensions
    page4.drawText('**Note - these dimensions may change depending on your preferred assembly method!! See next section**', {
      x: margin,
      y: yPos,
      size: 10,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
    yPos -= 30;
    
    // Embed sheet images (50% of remaining height, organized side by side)
    const availableHeight = yPos - margin;
    const imageHeight = availableHeight * 0.5;
    const startIndex = pageIndex * sheetsPerPage;
    const endIndex = Math.min(startIndex + sheetsPerPage, sheetSvgs.length);
    
    let currentX = margin;
    
    for (let i = startIndex; i < endIndex; i++) {
      try {
        const pngBytes = await svgToPng(sheetSvgs[i], {
          width: 250, // Tight around 4:8 ratio content + minimal margins
          height: 500, // Includes title space and dimension space
          scale: 2
        });
        
        const pngImage = await pdfDoc.embedPng(pngBytes);
        const scaledDims = pngImage.scale(imageHeight / 500);
        
        page4.drawImage(pngImage, {
          x: currentX,
          y: yPos - scaledDims.height,
          width: scaledDims.width,
          height: scaledDims.height,
        });
        
        currentX += scaledDims.width;
        
      } catch (error) {
        console.warn(`Failed to embed sheet ${i}:`, error);
        
        // Fallback placeholder - use reasonable dimensions
        const fallbackWidth = 200;
        
        page3.drawRectangle({
          x: currentX,
          y: yPos - imageHeight,
          width: fallbackWidth,
          height: imageHeight,
          borderColor: rgb(0.8, 0.8, 0.8),
          borderWidth: 1,
        });
        
        page4.drawText('Sheet diagram unavailable', {
          x: currentX + fallbackWidth/2 - 60,
          y: yPos - imageHeight/2,
          size: 10,
          font: helveticaFont,
          color: rgb(0.6, 0.6, 0.6),
        });
        
        currentX += fallbackWidth;
      }
    }
  }
  
  // ===== Oversized Parts Page (if any) =====
  if (layoutResult.oversizedParts.length > 0) {
    const oversizedPage = addPage();
    yPos = pageHeight - margin;
    
    // Header
    oversizedPage.drawText('Cut List', {
      x: margin,
      y: yPos,
      size: 20,
      font: helveticaBoldFont,
    });
    yPos -= 40;
    
    // "Does Not Fit" section title
    oversizedPage.drawText('Parts That Do Not Fit Standard Sheets', {
      x: margin,
      y: yPos,
      size: 16,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
    yPos -= 25;
    
    // Explanation text
    const explanationText = 'The following parts exceed the dimensions of standard 4\' × 8\' plywood sheets and will need to be sourced separately or assembled from multiple pieces:';
    
    // Wrap explanation text
    const words = explanationText.split(' ');
    let currentLine = '';
    const textLines: string[] = [];
    
    for (const word of words) {
      const testLine = currentLine + (currentLine ? ' ' : '') + word;
      if (testLine.length * 6 > contentWidth) {
        if (currentLine) textLines.push(currentLine);
        currentLine = word;
      } else {
        currentLine = testLine;
      }
    }
    if (currentLine) textLines.push(currentLine);
    
    for (const line of textLines) {
      oversizedPage.drawText(line, {
        x: margin,
        y: yPos,
        size: 11,
        font: helveticaFont,
        color: rgb(0, 0, 0),
      });
      yPos -= 14;
    }
    yPos -= 20;
    
    // Display oversized parts with simplified images and text
    const partsPerRow = 2;
    const partImageWidth = (contentWidth - 40) / partsPerRow; // Some spacing between images
    const partImageHeight = 120;
    
    for (let i = 0; i < layoutResult.oversizedParts.length; i++) {
      const oversizedPart = layoutResult.oversizedParts[i];
      const row = Math.floor(i / partsPerRow);
      const col = i % partsPerRow;
      
      const partX = margin + col * (partImageWidth + 20);
      const partY = yPos - (row * (partImageHeight + 80)) - partImageHeight;
      
      // Check if we need a new page
      if (partY < margin + 60) {
        // Start new page if needed
        const newOversizedPage = addPage();
        yPos = pageHeight - margin - 40; // Reset Y position
        // Recalculate position for new page
        const newPartY = yPos - partImageHeight;
        
        // Use the new page and position
        await renderOversizedPart(newOversizedPage, partX, newPartY, oversizedPart, partImageWidth, partImageHeight, i);
      } else {
        await renderOversizedPart(oversizedPage, partX, partY, oversizedPart, partImageWidth, partImageHeight, i);
      }
    }
  }
  
  // Helper function to render an oversized part
  async function renderOversizedPart(page: any, x: number, y: number, oversizedPart: any, width: number, height: number, index: number) {
    const part = oversizedPart.part;
    
    try {
      // Calculate proper dimensions based on part's actual aspect ratio
      const partAspectRatio = part.widthIn / part.lengthIn;
      const availableAspectRatio = width / height;
      
      let imageWidth, imageHeight;
      if (partAspectRatio > availableAspectRatio) {
        // Part is wider relative to available space - limit by width
        imageWidth = width;
        imageHeight = width / partAspectRatio;
      } else {
        // Part is taller relative to available space - limit by height
        imageHeight = height;
        imageWidth = height * partAspectRatio;
      }
      
      // Generate and embed the simplified SVG with natural aspect ratio
      const pngBytes = await svgToPng(oversizedSvgs[index], {
        width: Math.round(imageWidth * 2), // 2x for better quality
        height: Math.round(imageHeight * 2),
        scale: 1
      });
      
      const pngImage = await pdfDoc.embedPng(pngBytes);
      
      // Center the image in the available space
      const imageX = x + (width - imageWidth) / 2;
      const imageY = y + (height - imageHeight) / 2;
      
      page.drawImage(pngImage, {
        x: imageX,
        y: imageY,
        width: imageWidth,
        height: imageHeight,
      });
      
    } catch (error) {
      console.warn('Failed to embed oversized part image:', error);
      
      // Fallback: simple rectangle
      page.drawRectangle({
        x: x + width/4,
        y: y + height/4,
        width: width/2,
        height: height/2,
        borderColor: rgb(0.8, 0.8, 0.8),
        borderWidth: 1,
      });
    }
    
    // Part details text below image
    const textY = y - 20;
    
    // Center text manually
    const partIdText = `${part.id}`;
    const partIdWidth = helveticaBoldFont.widthOfTextAtSize(partIdText, 12);
    page.drawText(partIdText, {
      x: x + (width - partIdWidth) / 2,
      y: textY,
      size: 12,
      font: helveticaBoldFont,
      color: rgb(0, 0, 0),
    });
    
    const dimensionText = `${part.widthIn.toFixed(2)}" × ${part.lengthIn.toFixed(2)}" × ${part.thicknessIn.toFixed(3)}"`;
    const dimensionWidth = helveticaFont.widthOfTextAtSize(dimensionText, 10);
    page.drawText(dimensionText, {
      x: x + (width - dimensionWidth) / 2,
      y: textY - 15,
      size: 10,
      font: helveticaFont,
      color: rgb(0.3, 0.3, 0.3),
    });
    
    const reasonText = `Reason: ${oversizedPart.reason}`;
    const reasonWidth = helveticaFont.widthOfTextAtSize(reasonText, 9);
    page.drawText(reasonText, {
      x: x + (width - reasonWidth) / 2,
      y: textY - 30,
      size: 9,
      font: helveticaFont,
      color: rgb(0.6, 0, 0),
    });
  }
  
  // ===== PAGE 5: Thank You =====
  const page5 = addPage();
  yPos = pageHeight - margin;
  
  // Header
  page5.drawText('Thank you!', {
    x: margin,
    y: yPos,
    size: 20,
    font: helveticaBoldFont,
  });
  yPos -= 60;
  
  // Body
  page5.drawText('Hope this helps. If you have any images to share of what you build, send them to me at adamvosburgh@gmail.com!', {
    x: margin,
    y: yPos,
    size: 12,
    font: helveticaFont,
  });
  
  const pdfBytes = await pdfDoc.save();
  return pdfBytes;
}